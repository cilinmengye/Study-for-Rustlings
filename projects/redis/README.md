### 实现思路

* 核心实现采用`HashMap`, 更多的工作其实还是在实现服务端和客户端网络之间的通信
* 服务端
  1. 建立和客户端的网络连接 --  通过TCP端口的方式`tokio::net::{TcpListener, TcpStream}` 
  2. 任务级并发`tokio::spawn`,  任务的工作为处理客户端传递来的命令`GET`和`Set` 
     1. 主线程不断loop，接收来自客户端的请求数据，创建任务处理请求数据
     2. 创建任务之间共享的`HashMap`，数据存储和获取均于此
     3. 任务发送信息回复客户端
* 客户端
  1. 建立和服务端的网络连接 -- 通过TCP端口的方式`tokio::net::{TcpListener, TcpStream}` 
  2. 建立和客户之前的连接 -- 通过消息队列`tokio::sync::mpsc`处理来自用户的批量请求，统一发送给客户端并接收来自服务端的回复
     1. 可以理解为： 客户 <--> 客户端请求管理器 <--> 服务端；
        * 客户 --> 客户端请求管理器 之间通过`tokio::sync::mpsc`传递信息， `tokio::sync::mpsc` 为**多生成者，单消费者**; 客户批量发送信息，客户端请求管理器一个一个地接收信息，可能会成为瓶颈
        * 客户 <-- 客户端请求管理器 之间通过`tokio::sync::oneshot`传递信息，每个客户请求由一个任务管理并发送给客户端请求管理器，客户任务持有`tokio::sync::oneshot`的接收端句柄，客户端请求管理器持有`tokio::sync::oneshot`的发送端句柄
        * 客户端请求管理器 <--> 服务端 之间通过`tokio::net::{TcpListener, TcpStream}` 传递信息

* 处理用户输入
  * 我希望达到 -- 客户输入完后 客户端能够异步地处理客户的请求而不阻塞客户下一次的输入，同时能够终端能够输出`>>>`来模仿一个较好的终端效果
  * 为了避免客户端主线程和客户端任务之间的输出混乱掉终端，我再使用了一个消息传递，客户端主线程持有接收端句柄，客户端任务持有发送端句柄，客户端任务的任何响应都统一发送给客户端主线程，客户端主线程再统一打印到终端上。
* 优雅的关闭



使用方式：

* 客户端: `cargo run --bin cli`
  * 支持 `set foo 1`, `get foo` 类似command，支持错误command汇报
  * 支持`exit`退出

* 服务器端：`cargo run --bin server`
* 需要先启动服务器端再启动客户端